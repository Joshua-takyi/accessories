"use client";
import { useSearchParams, useRouter } from "next/navigation";
import { useQuery } from "@tanstack/react-query";
import { useInView } from "react-intersection-observer";
import axios from "axios";
import { useCallback, useEffect, useMemo, useState } from "react";
import Loading from "./loading";
const API_URI = process.env.NEXT_PUBLIC_API_URL;

export default function CollectionComponent() {
	const searchParams = useSearchParams();
	const router = useRouter();

	// Parse URL parameters
	const category = searchParams.get("category") || "case";
	const sortBy = searchParams.get("sortBy") || "price";
	const sortOrder = searchParams.get("sortOrder") || "desc";
	const tags = searchParams.get("tags") || "";
	const modelsParam = searchParams.get("models");
	const limit = parseInt(searchParams.get("limit") || "15", 10);
	const pageParam = parseInt(searchParams.get("page") || "1", 10);

	// State management
	const [page, setPage] = useState(pageParam);
	const [allProducts, setAllProducts] = useState([]);
	const [hasMore, setHasMore] = useState(true);

	// Parse models safely
	const models = useMemo(() => {
		try {
			return modelsParam ? JSON.parse(modelsParam) : [];
		} catch (e) {
			console.error("Error parsing models:", e);
			return [];
		}
	}, [modelsParam]);

	// Infinite scroll observer
	const { ref: lastProductRef, inView } = useInView({ threshold: 0.5 });

	// Fetch products function
	const fetchProducts = useCallback(async () => {
		try {
			const modelsQuery =
				models.length > 0 ? encodeURIComponent(JSON.stringify(models)) : "";
			const res = await axios.get(
				`${API_URI}/products/getItem?category=${category}&sortBy=${sortBy}&sortOrder=${sortOrder}&page=${page}&limit=${limit}&models=${modelsQuery}&tags=${tags}`
			);
			if (res.status !== 200) throw new Error("Failed to fetch products");
			return res.data.data || [];
		} catch (error) {
			console.error("Fetch Error:", error);
			throw new Error("Failed to fetch products");
		}
	}, [category, sortBy, sortOrder, page, limit, models, tags]);

	// Query setup
	const {
		data = [],
		isLoading,
		isError,
	} = useQuery({
		queryKey: [
			"products",
			category,
			sortBy,
			sortOrder,
			page,
			tags,
			modelsParam,
		],
		queryFn: fetchProducts,
		enabled: !!category,
		staleTime: 1000 * 60 * 5, // 5 minutes
	});

	// Update product list on data fetch
	useEffect(() => {
		if (data) {
			setAllProducts((prev) => (page === 1 ? data : [...prev, ...data]));
			setHasMore(data.length === limit);
		}
	}, [data, page, limit]);

	// Reset pagination on category, sort, or filters change
	useEffect(() => {
		setPage(1);
		setAllProducts([]);
		setHasMore(true);
	}, [category, sortBy, sortOrder, modelsParam, tags]);

	// Infinite scroll logic with safety check
	useEffect(() => {
		if (inView && !isLoading && hasMore) {
			setPage((prev) => prev + 1);
		}
	}, [inView, isLoading, hasMore]);

	// Handle filter changes
	const handleFilterChange = useCallback(
		(selectedModels) => {
			const params = new URLSearchParams(searchParams.toString());

			if (selectedModels.length > 0) {
				params.set("models", JSON.stringify(selectedModels));
			} else {
				params.delete("models");
			}

			params.set("category", category);
			params.set("sortBy", sortBy);
			params.set("sortOrder", sortOrder);
			params.set("limit", String(limit));
			params.set("page", "1");

			router.replace(`?${params.toString()}`, undefined, { shallow: true });
		},
		[router, searchParams, category, sortBy, sortOrder, limit]
	);

	// Handle pagination via buttons
	const handlePageChange = (newPage) => {
		if (newPage < 1) return;
		const params = new URLSearchParams(searchParams.toString());
		params.set("page", newPage.toString());
		router.replace(`?${params.toString()}`, undefined, { shallow: true });
		setPage(newPage);
	};

	// Loading & Error states
	if (isLoading && page === 1) return <Loading />;
	if (isError) {
		return (
			<div className="col-span-full flex flex-col items-center justify-center">
				<p className="text-red-500">
					Error fetching products. Try again later.
				</p>
			</div>
		);
	}

	return (
		<main className="w-full min-h-screen">
			<Wrapper className="flex flex-col md:flex-row p-3">
				{/* Sidebar */}
				<aside className="md:w-64 flex-shrink-0">
					<ColSideBar category={category} onFilterChange={handleFilterChange} />
				</aside>

				{/* Product Grid */}
				<section className="flex-1">
					<div className="grid md:grid-cols-4 grid-cols-2 gap-4 w-full">
						{allProducts.map((product, index) => (
							<div
								key={`${product._id}-${index}`}
								ref={index === allProducts.length - 1 ? lastProductRef : null}
							>
								<ProductCard
									name={product.itemName}
									price={product.price}
									image={product.image[0]}
									images={product.image}
									slug={product.slug}
									discount={product.discount}
								/>
							</div>
						))}

						{/* No products found */}
						{allProducts.length === 0 && !isLoading && (
							<div className="col-span-full flex flex-col items-center justify-center py-10">
								<h1 className="text-2xl font-bold">No products found</h1>
								<p className="text-gray-600">
									Try checking your spelling or using different keywords.
								</p>
							</div>
						)}
					</div>

					{/* Pagination Controls */}
					{allProducts.length > 0 && (
						<div className="flex justify-center items-center gap-2 mt-8">
							<button
								onClick={() => handlePageChange(page - 1)}
								disabled={page === 1}
								className="px-6 py-2.5 border border-gray-200 text-sm font-medium hover:bg-gray-50 transition disabled:opacity-40 disabled:cursor-not-allowed"
							>
								Previous
							</button>
							<span className="px-4 py-2">Page {page}</span>
							<button
								onClick={() => handlePageChange(page + 1)}
								disabled={!hasMore}
								className="px-6 py-2.5 border border-gray-200 text-sm font-medium hover:bg-gray-50 transition disabled:opacity-40 disabled:cursor-not-allowed"
							>
								Next
							</button>
						</div>
					)}
				</section>
			</Wrapper>
		</main>
	);
}
